#!/usr/bin/env node

'use strict';

const fs = require('fs');
const graphicsDefs = require('../src/graphicsDefs');
const path = require('path');

const RE_SVG_CONTENT = /<svg[^>]+>([\S\s]*?)<\/\s?svg>/m;

const [defs, masks] = generate(graphicsDefs);
const dir = path.resolve(process.argv[2]);
const template = `
<?xml version="1.0" encoding="utf-8"?>
<svg id="symbolDefs" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="0" width="0" style="position:absolute;">
${importPrimitives(path.resolve(__dirname, '../src/primitives'))}
${masks}
${defs}
</svg>
`;

fs.writeFileSync(path.resolve(dir, 'graphicsDefs.svg'), template);

function importPrimitives(primitivesPath) {
  const primitives = fs.readdirSync(primitivesPath);
  let str = '';

  for (const filepath of primitives) {
    const content = fs.readFileSync(path.resolve(primitivesPath, filepath));

    str += `${RE_SVG_CONTENT.exec(content)[1]}`;
  }

  return str;
}

function generate(graphicsDefs) {
  const masks = {};
  let defStr = '';

  for (const id in graphicsDefs) {
    const def = graphicsDefs[id];
    const parts = def.reduce((parts, part) => {
      if (Array.isArray(part)) {
        parts = parts.concat(part);
      } else {
        parts.push(part);
      }

      return parts;
    }, []).map(part => {
      const options = parseOptions(part);
      const use  = `<use class="${options.class}" xlink:href="#${options.primitive}" x="0" y="0" width="100" height="100" transform="translate(${options.x},${options.y}) scale(${options.scaleX},${options.scaleY})"></use>`;

      if (!options.mask) {
        return `    ${use}`;
      }

      const maskOptions = parseOptions(options.mask);
      const maskId = `${maskOptions.primitive}_${maskOptions.x}_${maskOptions.y}_${maskOptions.scaleX}_${maskOptions.scaleY}_${maskOptions.offset}`.replace(/[.]/g, '');

      masks[maskId] = generateMask(maskId, maskOptions);

      return `<g clip-path="url(#${maskId})">${use}</g>`;
    });

    defStr += `  <symbol id="${id}">\n${parts.join('\n')}\n  </symbol>\n`;
  }

  return [defStr, stringifyMasks(masks)];
}

function parseOptions(options) {
  options.x = Math.round(options.x);
  options.y = Math.round(options.y);
  options.scaleX = options.scaleX || 1;
  options.scaleY = options.scaleY || 1;
  options.variation = options.variation != null ? `${options.variation}` : '';
  options.class = `${options.primitive}${options.variation}-primitive`;

  return options;
}

function generateMask(id, options) {
  return `    <clipPath id="${id}">\n      <use xlink:href="#${options.primitive}" x="0" y="0" width="100" height="100" transform="translate(${options.x},${options.y}) scale(${options.scaleX},${options.scaleY})"></use>\n    </clipPath>`
  // return `<clipPath id="${id}"><circle cx="30" cy="30" r="20"/></clipPath>`
}

function stringifyMasks(masks) {
  let str = '  <defs>\n';

  for (const id in masks) {
    str += `${masks[id]}\n`;
  }

  str += '  </defs>\n';

  return str;
}